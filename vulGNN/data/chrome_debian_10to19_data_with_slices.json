[{"file_path": "../data/chrome_debian/raw_code_10to19/10_1.c", "code": "static void jbig2_set_bits ( byte * line , int x0 , int x1 ) {\n  int a0 , a1 , b0 , b1 , a ;\n  a0 = x0 >> 3 ;\n  a1 = x1 >> 3 ;\n  b0 = x0 & 7 ;\n  b1 = x1 & 7 ;\n  if ( a0 == a1 ) {\n  line [ a0 ] |= lm [ b0 ] & rm [ b1 ] ;\n  }\n  else {\n  line [ a0 ] |= lm [ b0 ] ;\n  for ( a = a0 + 1 ;\n  a < a1 ;\n  a ++ ) line [ a ] = 0xFF ;\n  if ( b1 ) line [ a1 ] |= rm [ b1 ] ;\n  }\n  }", "tokenized": "static void ID ( ID * ID , int ID , int ID ) { int ID , ID , ID , ID , ID ; ID = ID >> 3 ; ID = ID >> 3 ; ID = ID & 7 ; ID = ID & 7 ; if ( ID == ID ) { ID [ ID ] |= ID [ ID ] & ID [ ID ] ; } else { ID [ ID ] |= ID [ ID ] ; for ( ID = ID + 1 ; ID < ID ; ID ++ ) ID [ ID ] = 0 x F F ; if ( ID ) ID [ ID ] |= ID [ ID ] ; } }", "call_slices_vd": [], "call_slices_sy": [], "array_slices_vd": [[1, 3, 4, 5, 6, 7, 8], [1, 3, 4, 5, 7, 11], [1, 3, 4, 7, 12, 13, 14], [1, 3, 4, 5, 6, 7, 11, 12, 13, 14, 15]], "array_slices_sy": [[1, 3, 4, 5, 6, 7, 8], [1, 3, 4, 5, 7, 11, 15], [1, 3, 4, 7, 12, 13, 14, 15], [1, 3, 4, 5, 6, 7, 11, 12, 13, 14, 15]], "arith_slices_vd": [[1, 3, 4, 7, 12]], "arith_slices_sy": [[1, 3, 4, 7, 12, 13, 14, 15]], "ptr_slices_vd": [], "ptr_slices_sy": [], "label": 1}, {"file_path": "../data/chrome_debian/raw_code_10to19/11_0.c", "code": "int curl_msnprintf ( char * buffer , size_t maxlength , const char * format , ... ) {\n  int retcode ;\n  va_list ap_save ;\n  va_start ( ap_save , format ) ;\n  retcode = curl_mvsnprintf ( buffer , maxlength , format , ap_save ) ;\n  va_end ( ap_save ) ;\n  return retcode ;\n  }", "tokenized": "int ID ( char * ID , ID ID , const char * ID , ... ) { int ID ; ID ID ; ID ( ID , ID ) ; ID = ID ( ID , ID , ID , ID ) ; ID ( ID ) ; return ID ; }", "call_slices_vd": [], "call_slices_sy": [], "array_slices_vd": [], "array_slices_sy": [], "arith_slices_vd": [], "arith_slices_sy": [], "ptr_slices_vd": [], "ptr_slices_sy": [], "label": 0}, {"file_path": "../data/chrome_debian/raw_code_10to19/11_1.c", "code": "static int jbig2_find_changing_element ( const byte * line , int x , int w ) {\n  int a , b ;\n  if ( line == 0 ) return w ;\n  if ( x == - 1 ) {\n  a = 0 ;\n  x = 0 ;\n  }\n  else {\n  a = getbit ( line , x ) ;\n  x ++ ;\n  }\n  while ( x < w ) {\n  b = getbit ( line , x ) ;\n  if ( a != b ) break ;\n  x ++ ;\n  }\n  return x ;\n  }", "tokenized": "static int ID ( const ID * ID , int ID , int ID ) { int ID , ID ; if ( ID == 0 ) return ID ; if ( ID == - 1 ) { ID = 0 ; ID = 0 ; } else { ID = ID ( ID , ID ) ; ID ++ ; } while ( ID < ID ) { ID = ID ( ID , ID ) ; if ( ID != ID ) break ; ID ++ ; } return ID ; }", "call_slices_vd": [], "call_slices_sy": [], "array_slices_vd": [], "array_slices_sy": [], "arith_slices_vd": [], "arith_slices_sy": [], "ptr_slices_vd": [], "ptr_slices_sy": [], "label": 1}, {"file_path": "../data/chrome_debian/raw_code_10to19/12_0.c", "code": "static int storebuffer ( int output , FILE * data ) {\n  char * * buffer = ( char * * ) data ;\n  unsigned char outc = ( unsigned char ) output ;\n  * * buffer = outc ;\n  ( * buffer ) ++ ;\n  return outc ;\n  }", "tokenized": "static int ID ( int ID , ID * ID ) { char * * ID = ( char * * ) ID ; unsigned char ID = ( unsigned char ) ID ; * * ID = ID ; ( * ID ) ++ ; return ID ; }", "call_slices_vd": [], "call_slices_sy": [], "array_slices_vd": [], "array_slices_sy": [], "arith_slices_vd": [], "arith_slices_sy": [], "ptr_slices_vd": [], "ptr_slices_sy": [], "label": 0}, {"file_path": "../data/chrome_debian/raw_code_10to19/12_1.c", "code": "static int jbig2_find_changing_element_of_color ( const byte * line , int x , int w , int color ) {\n  if ( line == 0 ) return w ;\n  x = jbig2_find_changing_element ( line , x , w ) ;\n  if ( x < w && getbit ( line , x ) != color ) x = jbig2_find_changing_element ( line , x , w ) ;\n  return x ;\n  }", "tokenized": "static int ID ( const ID * ID , int ID , int ID , int ID ) { if ( ID == 0 ) return ID ; ID = ID ( ID , ID , ID ) ; if ( ID < ID && ID ( ID , ID ) != ID ) ID = ID ( ID , ID , ID ) ; return ID ; }", "call_slices_vd": [], "call_slices_sy": [], "array_slices_vd": [], "array_slices_sy": [], "arith_slices_vd": [], "arith_slices_sy": [], "ptr_slices_vd": [], "ptr_slices_sy": [], "label": 1}, {"file_path": "../data/chrome_debian/raw_code_10to19/13_0.c", "code": "static __inline __uint32_t __uint32_identity ( __uint32_t __x ) {\n  return __x ;\n  }", "tokenized": "static __inline ID ID ( ID ID ) { return ID ; }", "call_slices_vd": [], "call_slices_sy": [], "array_slices_vd": [], "array_slices_sy": [], "arith_slices_vd": [], "arith_slices_sy": [], "ptr_slices_vd": [], "ptr_slices_sy": [], "label": 0}, {"file_path": "../data/chrome_debian/raw_code_10to19/13_1.c", "code": "int jbig2_decode_halftone_mmr ( Jbig2Ctx * ctx , const Jbig2GenericRegionParams * params , const byte * data , size_t size , Jbig2Image * image , size_t * consumed_bytes ) {\n  Jbig2MmrCtx mmr ;\n  const int rowstride = image -> stride ;\n  byte * dst = image -> data ;\n  byte * ref = NULL ;\n  int y ;\n  int code = 0 ;\n  const uint32_t EOFB = 0x001001 ;\n  jbig2_decode_mmr_init ( & mmr , image -> width , image -> height , data , size ) ;\n  for ( y = 0 ;\n  y < image -> height ;\n  y ++ ) {\n  memset ( dst , 0 , rowstride ) ;\n  code = jbig2_decode_mmr_line ( & mmr , ref , dst ) ;\n  if ( code < 0 ) return code ;\n  ref = dst ;\n  dst += rowstride ;\n  }\n  if ( mmr . word >> 8 == EOFB ) {\n  mmr . data_index += 3 ;\n  }\n  * consumed_bytes += mmr . data_index + ( mmr . bit_index >> 3 ) + ( mmr . bit_index > 0 ? 1 : 0 ) ;\n  return code ;\n  }", "tokenized": "int ID ( ID * ID , const ID * ID , const ID * ID , ID ID , ID * ID , ID * ID ) { ID ID ; const int ID = ID -> ID ; ID * ID = ID -> ID ; ID * ID = ID ; int ID ; int ID = 0 ; const ID ID = 0 x 0 0 1 0 0 1 ; ID ( & ID , ID -> ID , ID -> ID , ID , ID ) ; for ( ID = 0 ; ID < ID -> ID ; ID ++ ) { ID ( ID , 0 , ID ) ; ID = ID ( & ID , ID , ID ) ; if ( ID < 0 ) return ID ; ID = ID ; ID += ID ; } if ( ID . ID >> 8 == ID ) { ID . ID += 3 ; } * ID += ID . ID + ( ID . ID >> 3 ) + ( ID . ID > 0 ? 1 : 0 ) ; return ID ; }", "call_slices_vd": [[1, 3, 4, 5, 10, 11, 12, 13, 14, 15, 16, 17]], "call_slices_sy": [[1, 3, 4, 5, 10, 11, 12, 13, 14, 15, 16, 17]], "array_slices_vd": [], "array_slices_sy": [], "arith_slices_vd": [[1, 2, 3, 4, 5, 8, 10, 11, 12, 14, 15, 16, 17, 19, 20, 22]], "arith_slices_sy": [[1, 2, 3, 4, 5, 8, 10, 11, 12, 14, 15, 16, 17, 19, 20, 22]], "ptr_slices_vd": [[1, 3, 4, 5, 10, 11, 12, 14, 15, 16, 17], [1, 9], [1, 3], [1, 4]], "ptr_slices_sy": [[1, 3, 4, 5, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 22, 23], [1, 9], [1, 3, 11, 12, 13, 14, 15, 16, 17, 19, 20, 22, 23], [1, 4, 11, 12, 13, 14, 15, 16, 17, 19, 20, 22, 23]], "label": 1}, {"file_path": "../data/chrome_debian/raw_code_10to19/14_0.c", "code": "int curl_mvfprintf ( FILE * whereto , const char * format , va_list ap_save ) {\n  return dprintf_formatf ( whereto , fputc , format , ap_save ) ;\n  }", "tokenized": "int ID ( ID * ID , const char * ID , ID ID ) { return ID ( ID , ID , ID , ID ) ; }", "call_slices_vd": [], "call_slices_sy": [], "array_slices_vd": [], "array_slices_sy": [], "arith_slices_vd": [], "arith_slices_sy": [], "ptr_slices_vd": [], "ptr_slices_sy": [], "label": 0}, {"file_path": "../data/chrome_debian/raw_code_10to19/14_1.c", "code": "static void jbig2_decode_mmr_init ( Jbig2MmrCtx * mmr , int width , int height , const byte * data , size_t size ) {\n  int i ;\n  uint32_t word = 0 ;\n  mmr -> width = width ;\n  mmr -> height = height ;\n  mmr -> data = data ;\n  mmr -> size = size ;\n  mmr -> data_index = 0 ;\n  mmr -> bit_index = 0 ;\n  for ( i = 0 ;\n  i < size && i < 4 ;\n  i ++ ) word |= ( data [ i ] << ( ( 3 - i ) << 3 ) ) ;\n  mmr -> word = word ;\n  }", "tokenized": "static void ID ( ID * ID , int ID , int ID , const ID * ID , ID ID ) { int ID ; ID ID = 0 ; ID -> ID = ID ; ID -> ID = ID ; ID -> ID = ID ; ID -> ID = ID ; ID -> ID = 0 ; ID -> ID = 0 ; for ( ID = 0 ; ID < ID && ID < 4 ; ID ++ ) ID |= ( ID [ ID ] << ( ( 3 - ID ) << 3 ) ) ; ID -> ID = ID ; }", "call_slices_vd": [], "call_slices_sy": [], "array_slices_vd": [[1, 3, 10, 11, 12]], "array_slices_sy": [[1, 3, 10, 11, 12, 13]], "arith_slices_vd": [[1, 3, 10, 11, 12]], "arith_slices_sy": [[1, 3, 10, 11, 12, 13]], "ptr_slices_vd": [[1, 4], [1, 5], [1, 6], [1, 7], [1, 8], [1, 9], [1, 3, 10, 11, 12, 13]], "ptr_slices_sy": [[1, 4], [1, 5], [1, 6], [1, 7], [1, 8], [1, 9], [1, 3, 10, 11, 12, 13]], "label": 1}, {"file_path": "../data/chrome_debian/raw_code_10to19/15_0.c", "code": "char * curl_maprintf ( const char * format , ... ) {\n  va_list ap_save ;\n  int retcode ;\n  struct asprintf info ;\n  info . buffer = NULL ;\n  info . len = 0 ;\n  info . alloc = 0 ;\n  info . fail = 0 ;\n  va_start ( ap_save , format ) ;\n  retcode = dprintf_formatf ( & info , alloc_addbyter , format , ap_save ) ;\n  va_end ( ap_save ) ;\n  if ( ( - 1 == retcode ) || info . fail ) {\n  if ( info . alloc ) free ( info . buffer ) ;\n  return NULL ;\n  }\n  if ( info . alloc ) {\n  info . buffer [ info . len ] = 0 ;\n  return info . buffer ;\n  }\n  else return strdup ( \"\" ) ;\n  }", "tokenized": "char * ID ( const char * ID , ... ) { ID ID ; int ID ; struct ID ID ; ID . ID = ID ; ID . ID = 0 ; ID . ID = 0 ; ID . ID = 0 ; ID ( ID , ID ) ; ID = ID ( & ID , ID , ID , ID ) ; ID ( ID ) ; if ( ( - 1 == ID ) || ID . ID ) { if ( ID . ID ) ID ( ID . ID ) ; return ID ; } if ( ID . ID ) { ID . ID [ ID . ID ] = 0 ; return ID . ID ; } else return ID ( STRING ) ; }", "call_slices_vd": [[1, 2, 4, 5, 6, 7, 8, 10, 12, 16, 20], [1, 2, 4, 5, 6, 7, 8, 10, 12, 13]], "call_slices_sy": [[1, 2, 4, 5, 6, 7, 8, 10, 12, 16, 20], [1, 2, 4, 5, 6, 7, 8, 10, 12, 13]], "array_slices_vd": [[1, 2, 4, 5, 6, 7, 8, 10, 12, 16, 17]], "array_slices_sy": [[1, 2, 4, 5, 6, 7, 8, 10, 12, 16, 17]], "arith_slices_vd": [], "arith_slices_sy": [], "ptr_slices_vd": [], "ptr_slices_sy": [], "label": 0}, {"file_path": "../data/chrome_debian/raw_code_10to19/15_1.c", "code": "static int jbig2_decode_mmr_line ( Jbig2MmrCtx * mmr , const byte * ref , byte * dst ) {\n  int a0 = - 1 ;\n  int a1 , a2 , b1 , b2 ;\n  int c = 0 ;\n  while ( 1 ) {\n  uint32_t word = mmr -> word ;\n  if ( a0 >= mmr -> width ) break ;\n  if ( ( word >> ( 32 - 3 ) ) == 1 ) {\n  int white_run , black_run ;\n  jbig2_decode_mmr_consume ( mmr , 3 ) ;\n  if ( a0 == - 1 ) a0 = 0 ;\n  if ( c == 0 ) {\n  white_run = jbig2_decode_get_run ( mmr , jbig2_mmr_white_decode , 8 ) ;\n  black_run = jbig2_decode_get_run ( mmr , jbig2_mmr_black_decode , 7 ) ;\n  a1 = a0 + white_run ;\n  a2 = a1 + black_run ;\n  if ( a1 > mmr -> width ) a1 = mmr -> width ;\n  if ( a2 > mmr -> width ) a2 = mmr -> width ;\n  if ( a2 < a1 || a1 < 0 ) return - 1 ;\n  jbig2_set_bits ( dst , a1 , a2 ) ;\n  a0 = a2 ;\n  }\n  else {\n  black_run = jbig2_decode_get_run ( mmr , jbig2_mmr_black_decode , 7 ) ;\n  white_run = jbig2_decode_get_run ( mmr , jbig2_mmr_white_decode , 8 ) ;\n  a1 = a0 + black_run ;\n  a2 = a1 + white_run ;\n  if ( a1 > mmr -> width ) a1 = mmr -> width ;\n  if ( a2 > mmr -> width ) a2 = mmr -> width ;\n  if ( a1 < a0 || a0 < 0 ) return - 1 ;\n  jbig2_set_bits ( dst , a0 , a1 ) ;\n  a0 = a2 ;\n  }\n  }\n  else if ( ( word >> ( 32 - 4 ) ) == 1 ) {\n  jbig2_decode_mmr_consume ( mmr , 4 ) ;\n  b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n  b2 = jbig2_find_changing_element ( ref , b1 , mmr -> width ) ;\n  if ( c ) {\n  if ( b2 < a0 || a0 < 0 ) return - 1 ;\n  jbig2_set_bits ( dst , a0 , b2 ) ;\n  }\n  a0 = b2 ;\n  }\n  else if ( ( word >> ( 32 - 1 ) ) == 1 ) {\n  jbig2_decode_mmr_consume ( mmr , 1 ) ;\n  b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n  if ( c ) {\n  if ( b1 < a0 || a0 < 0 ) return - 1 ;\n  jbig2_set_bits ( dst , a0 , b1 ) ;\n  }\n  a0 = b1 ;\n  c = ! c ;\n  }\n  else if ( ( word >> ( 32 - 3 ) ) == 3 ) {\n  jbig2_decode_mmr_consume ( mmr , 3 ) ;\n  b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n  if ( b1 + 1 > mmr -> width ) break ;\n  if ( c ) {\n  if ( b1 + 1 < a0 || a0 < 0 ) return - 1 ;\n  jbig2_set_bits ( dst , a0 , b1 + 1 ) ;\n  }\n  a0 = b1 + 1 ;\n  c = ! c ;\n  }\n  else if ( ( word >> ( 32 - 6 ) ) == 3 ) {\n  jbig2_decode_mmr_consume ( mmr , 6 ) ;\n  b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n  if ( b1 + 2 > mmr -> width ) break ;\n  if ( c ) {\n  if ( b1 + 2 < a0 || a0 < 0 ) return - 1 ;\n  jbig2_set_bits ( dst , a0 , b1 + 2 ) ;\n  }\n  a0 = b1 + 2 ;\n  c = ! c ;\n  }\n  else if ( ( word >> ( 32 - 7 ) ) == 3 ) {\n  jbig2_decode_mmr_consume ( mmr , 7 ) ;\n  b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n  if ( b1 + 3 > mmr -> width ) break ;\n  if ( c ) {\n  if ( b1 + 3 < a0 || a0 < 0 ) return - 1 ;\n  jbig2_set_bits ( dst , a0 , b1 + 3 ) ;\n  }\n  a0 = b1 + 3 ;\n  c = ! c ;\n  }\n  else if ( ( word >> ( 32 - 3 ) ) == 2 ) {\n  jbig2_decode_mmr_consume ( mmr , 3 ) ;\n  b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n  if ( b1 - 1 < 0 ) break ;\n  if ( c ) {\n  if ( b1 - 1 < a0 || a0 < 0 ) return - 1 ;\n  jbig2_set_bits ( dst , a0 , b1 - 1 ) ;\n  }\n  a0 = b1 - 1 ;\n  c = ! c ;\n  }\n  else if ( ( word >> ( 32 - 6 ) ) == 2 ) {\n  jbig2_decode_mmr_consume ( mmr , 6 ) ;\n  b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n  if ( b1 - 2 < 0 ) break ;\n  if ( c ) {\n  if ( b1 - 2 < a0 || a0 < 0 ) return - 1 ;\n  jbig2_set_bits ( dst , a0 , b1 - 2 ) ;\n  }\n  a0 = b1 - 2 ;\n  c = ! c ;\n  }\n  else if ( ( word >> ( 32 - 7 ) ) == 2 ) {\n  jbig2_decode_mmr_consume ( mmr , 7 ) ;\n  b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n  if ( b1 - 3 < 0 ) break ;\n  if ( c ) {\n  if ( b1 - 3 < a0 || a0 < 0 ) return - 1 ;\n  jbig2_set_bits ( dst , a0 , b1 - 3 ) ;\n  }\n  a0 = b1 - 3 ;\n  c = ! c ;\n  }\n  else break ;\n  }\n  return 0 ;\n  }", "tokenized": "static int ID ( ID * ID , const ID * ID , ID * ID ) { int ID = - 1 ; int ID , ID , ID , ID ; int ID = 0 ; while ( 1 ) { ID ID = ID -> ID ; if ( ID >= ID -> ID ) break ; if ( ( ID >> ( 3 2 - 3 ) ) == 1 ) { int ID , ID ; ID ( ID , 3 ) ; if ( ID == - 1 ) ID = 0 ; if ( ID == 0 ) { ID = ID ( ID , ID , 8 ) ; ID = ID ( ID , ID , 7 ) ; ID = ID + ID ; ID = ID + ID ; if ( ID > ID -> ID ) ID = ID -> ID ; if ( ID > ID -> ID ) ID = ID -> ID ; if ( ID < ID || ID < 0 ) return - 1 ; ID ( ID , ID , ID ) ; ID = ID ; } else { ID = ID ( ID , ID , 7 ) ; ID = ID ( ID , ID , 8 ) ; ID = ID + ID ; ID = ID + ID ; if ( ID > ID -> ID ) ID = ID -> ID ; if ( ID > ID -> ID ) ID = ID -> ID ; if ( ID < ID || ID < 0 ) return - 1 ; ID ( ID , ID , ID ) ; ID = ID ; } } else if ( ( ID >> ( 3 2 - 4 ) ) == 1 ) { ID ( ID , 4 ) ; ID = ID ( ID , ID , ID -> ID , ! ID ) ; ID = ID ( ID , ID , ID -> ID ) ; if ( ID ) { if ( ID < ID || ID < 0 ) return - 1 ; ID ( ID , ID , ID ) ; } ID = ID ; } else if ( ( ID >> ( 3 2 - 1 ) ) == 1 ) { ID ( ID , 1 ) ; ID = ID ( ID , ID , ID -> ID , ! ID ) ; if ( ID ) { if ( ID < ID || ID < 0 ) return - 1 ; ID ( ID , ID , ID ) ; } ID = ID ; ID = ! ID ; } else if ( ( ID >> ( 3 2 - 3 ) ) == 3 ) { ID ( ID , 3 ) ; ID = ID ( ID , ID , ID -> ID , ! ID ) ; if ( ID + 1 > ID -> ID ) break ; if ( ID ) { if ( ID + 1 < ID || ID < 0 ) return - 1 ; ID ( ID , ID , ID + 1 ) ; } ID = ID + 1 ; ID = ! ID ; } else if ( ( ID >> ( 3 2 - 6 ) ) == 3 ) { ID ( ID , 6 ) ; ID = ID ( ID , ID , ID -> ID , ! ID ) ; if ( ID + 2 > ID -> ID ) break ; if ( ID ) { if ( ID + 2 < ID || ID < 0 ) return - 1 ; ID ( ID , ID , ID + 2 ) ; } ID = ID + 2 ; ID = ! ID ; } else if ( ( ID >> ( 3 2 - 7 ) ) == 3 ) { ID ( ID , 7 ) ; ID = ID ( ID , ID , ID -> ID , ! ID ) ; if ( ID + 3 > ID -> ID ) break ; if ( ID ) { if ( ID + 3 < ID || ID < 0 ) return - 1 ; ID ( ID , ID , ID + 3 ) ; } ID = ID + 3 ; ID = ! ID ; } else if ( ( ID >> ( 3 2 - 3 ) ) == 2 ) { ID ( ID , 3 ) ; ID = ID ( ID , ID , ID -> ID , ! ID ) ; if ( ID - 1 < 0 ) break ; if ( ID ) { if ( ID - 1 < ID || ID < 0 ) return - 1 ; ID ( ID , ID , ID - 1 ) ; } ID = ID - 1 ; ID = ! ID ; } else if ( ( ID >> ( 3 2 - 6 ) ) == 2 ) { ID ( ID , 6 ) ; ID = ID ( ID , ID , ID -> ID , ! ID ) ; if ( ID - 2 < 0 ) break ; if ( ID ) { if ( ID - 2 < ID || ID < 0 ) return - 1 ; ID ( ID , ID , ID - 2 ) ; } ID = ID - 2 ; ID = ! ID ; } else if ( ( ID >> ( 3 2 - 7 ) ) == 2 ) { ID ( ID , 7 ) ; ID = ID ( ID , ID , ID -> ID , ! ID ) ; if ( ID - 3 < 0 ) break ; if ( ID ) { if ( ID - 3 < ID || ID < 0 ) return - 1 ; ID ( ID , ID , ID - 3 ) ; } ID = ID - 3 ; ID = ! ID ; } else break ; } return 0 ; }", "call_slices_vd": [], "call_slices_sy": [], "array_slices_vd": [], "array_slices_sy": [], "arith_slices_vd": [[1, 2, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 35, 37, 38, 39, 40, 43, 45, 47, 48, 49, 52, 53, 55, 57, 58, 59, 60, 63, 64, 66, 68, 69, 70, 71, 74, 75, 77, 79, 80, 81, 82, 85, 86, 88, 90, 91, 92, 93, 96, 97, 99, 101, 102, 103, 104, 107, 108, 110, 112, 113, 114, 115, 118, 119], [1, 2, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 35, 37, 38, 39, 40, 43, 45, 47, 48, 49, 52, 53, 55, 57, 58, 59, 60, 61, 63, 64, 66, 68, 69, 70, 71, 74, 75, 77, 79, 80, 81, 82, 85, 86, 88, 90, 91, 92, 93, 96, 97, 99, 101, 102, 103, 104, 107, 108, 110, 112, 113, 114, 115, 118, 119], [1, 2, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 35, 37, 38, 39, 40, 43, 45, 47, 48, 49, 52, 53, 55, 57, 58, 59, 60, 63, 64, 66, 68, 69, 70, 71, 72, 74, 75, 77, 79, 80, 81, 82, 85, 86, 88, 90, 91, 92, 93, 96, 97, 99, 101, 102, 103, 104, 107, 108, 110, 112, 113, 114, 115, 118, 119], [1, 2, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 35, 37, 38, 39, 40, 43, 45, 47, 48, 49, 52, 53, 55, 57, 58, 59, 60, 63, 64, 66, 68, 69, 70, 71, 74, 75, 77, 79, 80, 81, 82, 83, 85, 86, 88, 90, 91, 92, 93, 96, 97, 99, 101, 102, 103, 104, 107, 108, 110, 112, 113, 114, 115, 118, 119], [1, 2, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 35, 37, 38, 39, 40, 43, 45, 47, 48, 49, 52, 53, 55, 57, 58, 59, 60, 63, 64, 66, 68, 69, 70, 71, 74, 75, 77, 79, 80, 81, 82, 85, 86, 88, 90, 91, 92, 93, 94, 96, 97, 99, 101, 102, 103, 104, 107, 108, 110, 112, 113, 114, 115, 118, 119], [1, 2, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 35, 37, 38, 39, 40, 43, 45, 47, 48, 49, 52, 53, 55, 57, 58, 59, 60, 63, 64, 66, 68, 69, 70, 71, 74, 75, 77, 79, 80, 81, 82, 85, 86, 88, 90, 91, 92, 93, 96, 97, 99, 101, 102, 103, 104, 105, 107, 108, 110, 112, 113, 114, 115, 118, 119], [1, 2, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 35, 37, 38, 39, 40, 43, 45, 47, 48, 49, 52, 53, 55, 57, 58, 59, 60, 63, 64, 66, 68, 69, 70, 71, 74, 75, 77, 79, 80, 81, 82, 85, 86, 88, 90, 91, 92, 93, 96, 97, 99, 101, 102, 103, 104, 107, 108, 110, 112, 113, 114, 115, 116, 118, 119]], "arith_slices_sy": [[1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 25, 26, 27, 28, 29, 30, 31, 32, 35, 36, 37, 38, 39, 40, 41, 43, 45, 46, 47, 48, 49, 50, 52, 53, 55, 56, 57, 58, 59, 60, 61, 63, 64, 66, 67, 68, 69, 70, 71, 72, 74, 75, 77, 78, 79, 80, 81, 82, 83, 85, 86, 88, 89, 90, 91, 92, 93, 94, 96, 97, 99, 100, 101, 102, 103, 104, 105, 107, 108, 110, 111, 112, 113, 114, 115, 116, 118, 119, 121, 123], [1, 2, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 35, 37, 38, 39, 40, 43, 45, 47, 48, 49, 52, 53, 55, 57, 58, 59, 60, 61, 63, 64, 66, 68, 69, 70, 71, 74, 75, 77, 79, 80, 81, 82, 85, 86, 88, 90, 91, 92, 93, 96, 97, 99, 101, 102, 103, 104, 107, 108, 110, 112, 113, 114, 115, 118, 119], [1, 2, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 35, 37, 38, 39, 40, 43, 45, 47, 48, 49, 52, 53, 55, 57, 58, 59, 60, 63, 64, 66, 68, 69, 70, 71, 72, 74, 75, 77, 79, 80, 81, 82, 85, 86, 88, 90, 91, 92, 93, 96, 97, 99, 101, 102, 103, 104, 107, 108, 110, 112, 113, 114, 115, 118, 119], [1, 2, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 35, 37, 38, 39, 40, 43, 45, 47, 48, 49, 52, 53, 55, 57, 58, 59, 60, 63, 64, 66, 68, 69, 70, 71, 74, 75, 77, 79, 80, 81, 82, 83, 85, 86, 88, 90, 91, 92, 93, 96, 97, 99, 101, 102, 103, 104, 107, 108, 110, 112, 113, 114, 115, 118, 119], [1, 2, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 35, 37, 38, 39, 40, 43, 45, 47, 48, 49, 52, 53, 55, 57, 58, 59, 60, 63, 64, 66, 68, 69, 70, 71, 74, 75, 77, 79, 80, 81, 82, 85, 86, 88, 90, 91, 92, 93, 94, 96, 97, 99, 101, 102, 103, 104, 107, 108, 110, 112, 113, 114, 115, 118, 119], [1, 2, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 35, 37, 38, 39, 40, 43, 45, 47, 48, 49, 52, 53, 55, 57, 58, 59, 60, 63, 64, 66, 68, 69, 70, 71, 74, 75, 77, 79, 80, 81, 82, 85, 86, 88, 90, 91, 92, 93, 96, 97, 99, 101, 102, 103, 104, 105, 107, 108, 110, 112, 113, 114, 115, 118, 119], [1, 2, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 35, 37, 38, 39, 40, 43, 45, 47, 48, 49, 52, 53, 55, 57, 58, 59, 60, 63, 64, 66, 68, 69, 70, 71, 74, 75, 77, 79, 80, 81, 82, 85, 86, 88, 90, 91, 92, 93, 96, 97, 99, 101, 102, 103, 104, 107, 108, 110, 112, 113, 114, 115, 116, 118, 119]], "ptr_slices_vd": [[1, 2, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 35, 37, 38, 39, 40, 43, 45, 47, 48, 49, 52, 53, 55, 57, 58, 59, 60, 63, 64, 66, 68, 69, 70, 71, 74, 75, 77, 79, 80, 81, 82, 85, 86, 88, 90, 91, 92, 93, 96, 97, 99, 101, 102, 103, 104, 107, 108, 110, 112, 113, 114, 115, 118, 119]], "ptr_slices_sy": [[1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 25, 26, 27, 28, 29, 30, 31, 32, 35, 36, 37, 38, 39, 40, 41, 43, 45, 46, 47, 48, 49, 50, 52, 53, 55, 56, 57, 58, 59, 60, 61, 63, 64, 66, 67, 68, 69, 70, 71, 72, 74, 75, 77, 78, 79, 80, 81, 82, 83, 85, 86, 88, 89, 90, 91, 92, 93, 94, 96, 97, 99, 100, 101, 102, 103, 104, 105, 107, 108, 110, 111, 112, 113, 114, 115, 116, 118, 119, 121, 123]], "label": 1}, {"file_path": "../data/chrome_debian/raw_code_10to19/16_0.c", "code": "static long dprintf_DollarString ( char * input , char * * end ) {\n  int number = 0 ;\n  while ( ISDIGIT ( * input ) ) {\n  number *= 10 ;\n  number += * input - '0' ;\n  input ++ ;\n  }\n  if ( number && ( '$' == * input ++ ) ) {\n  * end = input ;\n  return number ;\n  }\n  return 0 ;\n  }", "tokenized": "static long ID ( char * ID , char * * ID ) { int ID = 0 ; while ( ID ( * ID ) ) { ID *= 1 0 ; ID += * ID - LITERAL ; ID ++ ; } if ( ID && ( LITERAL == * ID ++ ) ) { * ID = ID ; return ID ; } return 0 ; }", "call_slices_vd": [], "call_slices_sy": [], "array_slices_vd": [], "array_slices_sy": [], "arith_slices_vd": [[1, 2, 3, 4, 5, 6]], "arith_slices_sy": [[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]], "ptr_slices_vd": [], "ptr_slices_sy": [], "label": 0}, {"file_path": "../data/chrome_debian/raw_code_10to19/16_1.c", "code": "Jbig2Segment * jbig2_parse_segment_header ( Jbig2Ctx * ctx , uint8_t * buf , size_t buf_size , size_t * p_header_size ) {\n  Jbig2Segment * result ;\n  uint8_t rtscarf ;\n  uint32_t rtscarf_long ;\n  uint32_t * referred_to_segments ;\n  int referred_to_segment_count ;\n  int referred_to_segment_size ;\n  int pa_size ;\n  int offset ;\n  if ( buf_size < 11 ) return NULL ;\n  result = jbig2_new ( ctx , Jbig2Segment , 1 ) ;\n  if ( result == NULL ) {\n  jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , - 1 , \"failed to allocate segment in jbig2_parse_segment_header\" ) ;\n  return result ;\n  }\n  result -> number = jbig2_get_uint32 ( buf ) ;\n  result -> flags = buf [ 4 ] ;\n  rtscarf = buf [ 5 ] ;\n  if ( ( rtscarf & 0xe0 ) == 0xe0 ) {\n  rtscarf_long = jbig2_get_uint32 ( buf + 5 ) ;\n  referred_to_segment_count = rtscarf_long & 0x1fffffff ;\n  offset = 5 + 4 + ( referred_to_segment_count + 1 ) / 8 ;\n  }\n  else {\n  referred_to_segment_count = ( rtscarf >> 5 ) ;\n  offset = 5 + 1 ;\n  }\n  result -> referred_to_segment_count = referred_to_segment_count ;\n  referred_to_segment_size = result -> number <= 256 ? 1 : result -> number <= 65536 ? 2 : 4 ;\n  pa_size = result -> flags & 0x40 ? 4 : 1 ;\n  if ( offset + referred_to_segment_count * referred_to_segment_size + pa_size + 4 > buf_size ) {\n  jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , result -> number , \"jbig2_parse_segment_header() called with insufficient data\" , - 1 ) ;\n  jbig2_free ( ctx -> allocator , result ) ;\n  return NULL ;\n  }\n  if ( referred_to_segment_count ) {\n  int i ;\n  referred_to_segments = jbig2_new ( ctx , uint32_t , referred_to_segment_count * referred_to_segment_size ) ;\n  if ( referred_to_segments == NULL ) {\n  jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , - 1 , \"could not allocate referred_to_segments \" \"in jbig2_parse_segment_header\" ) ;\n  return NULL ;\n  }\n  for ( i = 0 ;\n  i < referred_to_segment_count ;\n  i ++ ) {\n  referred_to_segments [ i ] = ( referred_to_segment_size == 1 ) ? buf [ offset ] : ( referred_to_segment_size == 2 ) ? jbig2_get_uint16 ( buf + offset ) : jbig2_get_uint32 ( buf + offset ) ;\n  offset += referred_to_segment_size ;\n  jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , result -> number , \"segment %d refers to segment %d\" , result -> number , referred_to_segments [ i ] ) ;\n  }\n  result -> referred_to_segments = referred_to_segments ;\n  }\n  else {\n  result -> referred_to_segments = NULL ;\n  }\n  if ( result -> flags & 0x40 ) {\n  result -> page_association = jbig2_get_uint32 ( buf + offset ) ;\n  offset += 4 ;\n  }\n  else {\n  result -> page_association = buf [ offset ++ ] ;\n  }\n  jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , result -> number , \"segment %d is associated with page %d\" , result -> number , result -> page_association ) ;\n  result -> data_length = jbig2_get_uint32 ( buf + offset ) ;\n  * p_header_size = offset + 4 ;\n  result -> result = NULL ;\n  return result ;\n  }", "tokenized": "ID * ID ( ID * ID , ID * ID , ID ID , ID * ID ) { ID * ID ; ID ID ; ID ID ; ID * ID ; int ID ; int ID ; int ID ; int ID ; if ( ID < 1 1 ) return ID ; ID = ID ( ID , ID , 1 ) ; if ( ID == ID ) { ID ( ID , ID , - 1 , LITERAL ) ; return ID ; } ID -> ID = ID ( ID ) ; ID -> ID = ID [ 4 ] ; ID = ID [ 5 ] ; if ( ( ID & 0 x e 0 ) == 0 x e 0 ) { ID = ID ( ID + 5 ) ; ID = ID & 0 x 1 f f f f f f f ; ID = 5 + 4 + ( ID + 1 ) / 8 ; } else { ID = ( ID >> 5 ) ; ID = 5 + 1 ; } ID -> ID = ID ; ID = ID -> ID <= 2 5 6 ? 1 : ID -> ID <= 6 5 5 3 6 ? 2 : 4 ; ID = ID -> ID & 0 x 4 0 ? 4 : 1 ; if ( ID + ID * ID + ID + 4 > ID ) { ID ( ID , ID , ID -> ID , LITERAL , - 1 ) ; ID ( ID -> ID , ID ) ; return ID ; } if ( ID ) { int ID ; ID = ID ( ID , ID , ID * ID ) ; if ( ID == ID ) { ID ( ID , ID , - 1 , LITERAL LITERAL ) ; return ID ; } for ( ID = 0 ; ID < ID ; ID ++ ) { ID [ ID ] = ( ID == 1 ) ? ID [ ID ] : ( ID == 2 ) ? ID ( ID + ID ) : ID ( ID + ID ) ; ID += ID ; ID ( ID , ID , ID -> ID , LITERAL , ID -> ID , ID [ ID ] ) ; } ID -> ID = ID ; } else { ID -> ID = ID ; } if ( ID -> ID & 0 x 4 0 ) { ID -> ID = ID ( ID + ID ) ; ID += 4 ; } else { ID -> ID = ID [ ID ++ ] ; } ID ( ID , ID , ID -> ID , LITERAL , ID -> ID , ID -> ID ) ; ID -> ID = ID ( ID + ID ) ; * ID = ID + 4 ; ID -> ID = ID ; return ID ; }", "call_slices_vd": [], "call_slices_sy": [], "array_slices_vd": [[1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 46, 47], [1, 10, 11, 12, 17], [1, 10, 11, 12, 18], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 47, 50, 53, 55, 60]], "array_slices_sy": [[1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 46, 47, 48], [1, 10, 11, 12, 17, 30, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 53, 55, 56, 57, 60, 62, 63, 64, 65, 66], [1, 10, 11, 12, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 53, 55, 56, 57, 60, 62, 63, 64, 65, 66], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 47, 50, 53, 55, 60, 62, 63, 64]], "arith_slices_vd": [[1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 47, 50, 53, 55, 57, 60, 64], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 46, 47], [1, 10, 11, 12, 18, 19, 20], [1, 10, 11, 12, 18, 19, 20, 21, 22], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 47, 50, 53, 55, 56], [1, 10, 11, 12, 18, 19, 26], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 47, 50, 53, 55, 57, 60, 63], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31]], "arith_slices_sy": [[1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 47, 50, 53, 55, 57, 60, 64], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 55, 56, 57, 60, 62, 63, 64, 65, 66], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 46, 47, 48], [1, 10, 11, 12, 18, 19, 20, 21, 22, 28, 29, 30, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 53, 55, 56, 57, 60, 62, 63, 64, 65, 66], [1, 10, 11, 12, 18, 19, 20, 21, 22, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 53, 55, 56, 57, 60, 62, 63, 64, 65, 66], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 47, 50, 53, 55, 56, 62], [1, 10, 11, 12, 18, 19, 26, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 53, 55, 56, 57, 60, 62, 63, 64, 65, 66], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 47, 50, 53, 55, 57, 60, 63], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 53, 55, 56, 57, 60, 62, 63, 64, 65, 66]], "ptr_slices_vd": [[1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 32], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 33], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 65], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 47, 50, 53, 55, 60], [1, 10, 11, 12, 16], [1, 10, 11, 12, 17], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 46, 47, 48], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 50], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 53], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 50, 53, 55], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 47, 50, 53, 55, 56], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 47, 50, 53, 55, 56, 60, 62], [1, 10, 11, 12, 18, 19, 20, 21, 25, 28], [1, 10, 11, 12, 16, 18, 19, 20, 21, 25, 28, 29], [1, 10, 11, 12, 17, 18, 19, 20, 21, 25, 28, 30], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 47, 50, 53, 55, 57, 60, 63]], "ptr_slices_sy": [[1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 32], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 33], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 65], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 47, 50, 53, 55, 60, 62, 63, 64], [1, 10, 11, 12, 16, 29, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 53, 55, 56, 57, 60, 62, 63, 64, 65, 66], [1, 10, 11, 12, 17, 30, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 53, 55, 56, 57, 60, 62, 63, 64, 65, 66], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 46, 47, 48], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 50, 55, 56, 57, 60, 62, 63, 64], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 53, 55, 56, 57, 60, 62, 63, 64], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 50, 53, 55, 56, 57, 60, 62, 63, 64], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 47, 50, 53, 55, 56, 62], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 47, 50, 53, 55, 56, 60, 62], [1, 10, 11, 12, 18, 19, 20, 21, 25, 28, 29, 30, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 53, 55, 56, 57, 60, 62, 63, 64, 65, 66], [1, 10, 11, 12, 16, 18, 19, 20, 21, 25, 28, 29, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 53, 55, 56, 57, 60, 62, 63, 64, 65, 66], [1, 10, 11, 12, 17, 18, 19, 20, 21, 25, 28, 30, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 53, 55, 56, 57, 60, 62, 63, 64, 65, 66], [1, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 25, 26, 28, 29, 30, 31, 36, 38, 39, 43, 44, 45, 47, 50, 53, 55, 57, 60, 63]], "label": 1}, {"file_path": "../data/chrome_debian/raw_code_10to19/17_0.c", "code": "static int dprintf_formatf ( void * data , int ( * stream ) ( int , FILE * ) , const char * format , va_list ap_save ) {\n  const char * digits = lower_digits ;\n  char * f ;\n  int done = 0 ;\n  long param ;\n  long param_num = 0 ;\n  va_stack_t vto [ MAX_PARAMETERS ] ;\n  char * endpos [ MAX_PARAMETERS ] ;\n  char * * end ;\n  char work [ BUFFSIZE ] ;\n  va_stack_t * p ;\n  char * workend = & work [ sizeof ( work ) - 2 ] ;\n  if ( dprintf_Pass1 ( format , vto , endpos , ap_save ) ) return - 1 ;\n  end = & endpos [ 0 ] ;\n  f = ( char * ) format ;\n  while ( * f != '\\0' ) {\n  int is_alt ;\n  long width ;\n  long prec ;\n  int is_neg ;\n  long base ;\n  mp_uintmax_t num ;\n  mp_intmax_t signed_num ;\n  char * w ;\n  if ( * f != '%' ) {\n  do {\n  OUTCHAR ( * f ) ;\n  }\n  while ( * ++ f && ( '%' != * f ) ) ;\n  continue ;\n  }\n  ++ f ;\n  if ( * f == '%' ) {\n  ++ f ;\n  OUTCHAR ( '%' ) ;\n  continue ;\n  }\n  param = dprintf_DollarString ( f , & f ) ;\n  if ( ! param ) param = param_num ;\n  else -- param ;\n  param_num ++ ;\n  p = & vto [ param ] ;\n  if ( p -> flags & FLAGS_WIDTHPARAM ) {\n  width = ( long ) vto [ p -> width ] . data . num . as_signed ;\n  param_num ++ ;\n  if ( width < 0 ) {\n  width = - width ;\n  p -> flags |= FLAGS_LEFT ;\n  p -> flags &= ~ FLAGS_PAD_NIL ;\n  }\n  }\n  else width = p -> width ;\n  if ( p -> flags & FLAGS_PRECPARAM ) {\n  prec = ( long ) vto [ p -> precision ] . data . num . as_signed ;\n  param_num ++ ;\n  if ( prec < 0 ) prec = - 1 ;\n  }\n  else if ( p -> flags & FLAGS_PREC ) prec = p -> precision ;\n  else prec = - 1 ;\n  is_alt = ( p -> flags & FLAGS_ALT ) ? 1 : 0 ;\n  switch ( p -> type ) {\n  case FORMAT_INT : num = p -> data . num . as_unsigned ;\n  if ( p -> flags & FLAGS_CHAR ) {\n  if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( -- width > 0 ) OUTCHAR ( ' ' ) ;\n  OUTCHAR ( ( char ) num ) ;\n  if ( p -> flags & FLAGS_LEFT ) while ( -- width > 0 ) OUTCHAR ( ' ' ) ;\n  break ;\n  }\n  if ( p -> flags & FLAGS_OCTAL ) {\n  base = 8 ;\n  goto unsigned_number ;\n  }\n  else if ( p -> flags & FLAGS_HEX ) {\n  digits = ( p -> flags & FLAGS_UPPER ) ? upper_digits : lower_digits ;\n  base = 16 ;\n  goto unsigned_number ;\n  }\n  else if ( p -> flags & FLAGS_UNSIGNED ) {\n  base = 10 ;\n  goto unsigned_number ;\n  }\n  base = 10 ;\n  is_neg = ( p -> data . num . as_signed < ( mp_intmax_t ) 0 ) ? 1 : 0 ;\n  if ( is_neg ) {\n  signed_num = p -> data . num . as_signed + ( mp_intmax_t ) 1 ;\n  signed_num = - signed_num ;\n  num = ( mp_uintmax_t ) signed_num ;\n  num += ( mp_uintmax_t ) 1 ;\n  }\n  goto number ;\n  unsigned_number : is_neg = 0 ;\n  number : if ( prec == - 1 ) prec = 1 ;\n  w = workend ;\n  while ( num > 0 ) {\n  * w -- = digits [ num % base ] ;\n  num /= base ;\n  }\n  width -= ( long ) ( workend - w ) ;\n  prec -= ( long ) ( workend - w ) ;\n  if ( is_alt && base == 8 && prec <= 0 ) {\n  * w -- = '0' ;\n  -- width ;\n  }\n  if ( prec > 0 ) {\n  width -= prec ;\n  while ( prec -- > 0 ) * w -- = '0' ;\n  }\n  if ( is_alt && base == 16 ) width -= 2 ;\n  if ( is_neg || ( p -> flags & FLAGS_SHOWSIGN ) || ( p -> flags & FLAGS_SPACE ) ) -- width ;\n  if ( ! ( p -> flags & FLAGS_LEFT ) && ! ( p -> flags & FLAGS_PAD_NIL ) ) while ( width -- > 0 ) OUTCHAR ( ' ' ) ;\n  if ( is_neg ) OUTCHAR ( '-' ) ;\n  else if ( p -> flags & FLAGS_SHOWSIGN ) OUTCHAR ( '+' ) ;\n  else if ( p -> flags & FLAGS_SPACE ) OUTCHAR ( ' ' ) ;\n  if ( is_alt && base == 16 ) {\n  OUTCHAR ( '0' ) ;\n  if ( p -> flags & FLAGS_UPPER ) OUTCHAR ( 'X' ) ;\n  else OUTCHAR ( 'x' ) ;\n  }\n  if ( ! ( p -> flags & FLAGS_LEFT ) && ( p -> flags & FLAGS_PAD_NIL ) ) while ( width -- > 0 ) OUTCHAR ( '0' ) ;\n  while ( ++ w <= workend ) {\n  OUTCHAR ( * w ) ;\n  }\n  if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( ' ' ) ;\n  break ;\n  case FORMAT_STRING : {\n  static const char null [ ] = \"(nil)\" ;\n  const char * str ;\n  size_t len ;\n  str = ( char * ) p -> data . str ;\n  if ( str == NULL ) {\n  if ( prec == - 1 || prec >= ( long ) sizeof ( null ) - 1 ) {\n  str = null ;\n  len = sizeof ( null ) - 1 ;\n  p -> flags &= ( ~ FLAGS_ALT ) ;\n  }\n  else {\n  str = \"\" ;\n  len = 0 ;\n  }\n  }\n  else if ( prec != - 1 ) len = ( size_t ) prec ;\n  else len = strlen ( str ) ;\n  width -= ( len > LONG_MAX ) ? LONG_MAX : ( long ) len ;\n  if ( p -> flags & FLAGS_ALT ) OUTCHAR ( '\"' ) ;\n  if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( width -- > 0 ) OUTCHAR ( ' ' ) ;\n  while ( ( len -- > 0 ) && * str ) OUTCHAR ( * str ++ ) ;\n  if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( ' ' ) ;\n  if ( p -> flags & FLAGS_ALT ) OUTCHAR ( '\"' ) ;\n  }\n  break ;\n  case FORMAT_PTR : {\n  void * ptr ;\n  ptr = ( void * ) p -> data . ptr ;\n  if ( ptr != NULL ) {\n  base = 16 ;\n  digits = ( p -> flags & FLAGS_UPPER ) ? upper_digits : lower_digits ;\n  is_alt = 1 ;\n  num = ( size_t ) ptr ;\n  is_neg = 0 ;\n  goto number ;\n  }\n  else {\n  static const char strnil [ ] = \"(nil)\" ;\n  const char * point ;\n  width -= ( long ) ( sizeof ( strnil ) - 1 ) ;\n  if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( ' ' ) ;\n  for ( point = strnil ;\n  * point != '\\0' ;\n  ++ point ) OUTCHAR ( * point ) ;\n  if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( width -- > 0 ) OUTCHAR ( ' ' ) ;\n  }\n  }\n  break ;\n  case FORMAT_DOUBLE : {\n  char formatbuf [ 32 ] = \"%\" ;\n  char * fptr = & formatbuf [ 1 ] ;\n  size_t left = sizeof ( formatbuf ) - strlen ( formatbuf ) ;\n  int len ;\n  width = - 1 ;\n  if ( p -> flags & FLAGS_WIDTH ) width = p -> width ;\n  else if ( p -> flags & FLAGS_WIDTHPARAM ) width = ( long ) vto [ p -> width ] . data . num . as_signed ;\n  prec = - 1 ;\n  if ( p -> flags & FLAGS_PREC ) prec = p -> precision ;\n  else if ( p -> flags & FLAGS_PRECPARAM ) prec = ( long ) vto [ p -> precision ] . data . num . as_signed ;\n  if ( p -> flags & FLAGS_LEFT ) * fptr ++ = '-' ;\n  if ( p -> flags & FLAGS_SHOWSIGN ) * fptr ++ = '+' ;\n  if ( p -> flags & FLAGS_SPACE ) * fptr ++ = ' ' ;\n  if ( p -> flags & FLAGS_ALT ) * fptr ++ = '#' ;\n  * fptr = 0 ;\n  if ( width >= 0 ) {\n  len = curl_msnprintf ( fptr , left , \"%ld\" , width ) ;\n  fptr += len ;\n  left -= len ;\n  }\n  if ( prec >= 0 ) {\n  len = curl_msnprintf ( fptr , left , \".%ld\" , prec ) ;\n  fptr += len ;\n  }\n  if ( p -> flags & FLAGS_LONG ) * fptr ++ = 'l' ;\n  if ( p -> flags & FLAGS_FLOATE ) * fptr ++ = ( char ) ( ( p -> flags & FLAGS_UPPER ) ? 'E' : 'e' ) ;\n  else if ( p -> flags & FLAGS_FLOATG ) * fptr ++ = ( char ) ( ( p -> flags & FLAGS_UPPER ) ? 'G' : 'g' ) ;\n  else * fptr ++ = 'f' ;\n  * fptr = 0 ;\n  ( sprintf ) ( work , formatbuf , p -> data . dnum ) ;\n  for ( fptr = work ;\n  * fptr ;\n  fptr ++ ) OUTCHAR ( * fptr ) ;\n  }\n  break ;\n  case FORMAT_INTPTR : # ifdef HAVE_LONG_LONG_TYPE if ( p -> flags & FLAGS_LONGLONG ) * ( LONG_LONG_TYPE * ) p -> data . ptr = ( LONG_LONG_TYPE ) done ;\n  else # endif if ( p -> flags & FLAGS_LONG ) * ( long * ) p -> data . ptr = ( long ) done ;\n  else if ( ! ( p -> flags & FLAGS_SHORT ) ) * ( int * ) p -> data . ptr = ( int ) done ;\n  else * ( short * ) p -> data . ptr = ( short ) done ;\n  break ;\n  default : break ;\n  }\n  f = * end ++ ;\n  }\n  return done ;\n  }", "tokenized": "static int ID ( void * ID , int ( * ID ) ( int , ID * ) , const char * ID , ID ID ) { const char * ID = ID ; char * ID ; int ID = 0 ; long ID ; long ID = 0 ; ID ID [ ID ] ; char * ID [ ID ] ; char * * ID ; char ID [ ID ] ; ID * ID ; char * ID = & ID [ sizeof ( ID ) - 2 ] ; if ( ID ( ID , ID , ID , ID ) ) return - 1 ; ID = & ID [ 0 ] ; ID = ( char * ) ID ; while ( * ID != LITERAL ) { int ID ; long ID ; long ID ; int ID ; long ID ; ID ID ; ID ID ; char * ID ; if ( * ID != LITERAL ) { do { ID ( * ID ) ; } while ( * ++ ID && ( LITERAL != * ID ) ) ; continue ; } ++ ID ; if ( * ID == LITERAL ) { ++ ID ; ID ( LITERAL ) ; continue ; } ID = ID ( ID , & ID ) ; if ( ! ID ) ID = ID ; else -- ID ; ID ++ ; ID = & ID [ ID ] ; if ( ID -> ID & ID ) { ID = ( long ) ID [ ID -> ID ] . ID . ID . ID ; ID ++ ; if ( ID < 0 ) { ID = - ID ; ID -> ID |= ID ; ID -> ID &= ~ ID ; } } else ID = ID -> ID ; if ( ID -> ID & ID ) { ID = ( long ) ID [ ID -> ID ] . ID . ID . ID ; ID ++ ; if ( ID < 0 ) ID = - 1 ; } else if ( ID -> ID & ID ) ID = ID -> ID ; else ID = - 1 ; ID = ( ID -> ID & ID ) ? 1 : 0 ; switch ( ID -> ID ) { case ID : ID = ID -> ID . ID . ID ; if ( ID -> ID & ID ) { if ( ! ( ID -> ID & ID ) ) while ( -- ID > 0 ) ID ( LITERAL ) ; ID ( ( char ) ID ) ; if ( ID -> ID & ID ) while ( -- ID > 0 ) ID ( LITERAL ) ; break ; } if ( ID -> ID & ID ) { ID = 8 ; goto ID ; } else if ( ID -> ID & ID ) { ID = ( ID -> ID & ID ) ? ID : ID ; ID = 1 6 ; goto ID ; } else if ( ID -> ID & ID ) { ID = 1 0 ; goto ID ; } ID = 1 0 ; ID = ( ID -> ID . ID . ID < ( ID ) 0 ) ? 1 : 0 ; if ( ID ) { ID = ID -> ID . ID . ID + ( ID ) 1 ; ID = - ID ; ID = ( ID ) ID ; ID += ( ID ) 1 ; } goto ID ; ID : ID = 0 ; ID : if ( ID == - 1 ) ID = 1 ; ID = ID ; while ( ID > 0 ) { * ID -- = ID [ ID % ID ] ; ID /= ID ; } ID -= ( long ) ( ID - ID ) ; ID -= ( long ) ( ID - ID ) ; if ( ID && ID == 8 && ID <= 0 ) { * ID -- = LITERAL ; -- ID ; } if ( ID > 0 ) { ID -= ID ; while ( ID -- > 0 ) * ID -- = LITERAL ; } if ( ID && ID == 1 6 ) ID -= 2 ; if ( ID || ( ID -> ID & ID ) || ( ID -> ID & ID ) ) -- ID ; if ( ! ( ID -> ID & ID ) && ! ( ID -> ID & ID ) ) while ( ID -- > 0 ) ID ( LITERAL ) ; if ( ID ) ID ( LITERAL ) ; else if ( ID -> ID & ID ) ID ( LITERAL ) ; else if ( ID -> ID & ID ) ID ( LITERAL ) ; if ( ID && ID == 1 6 ) { ID ( LITERAL ) ; if ( ID -> ID & ID ) ID ( LITERAL ) ; else ID ( LITERAL ) ; } if ( ! ( ID -> ID & ID ) && ( ID -> ID & ID ) ) while ( ID -- > 0 ) ID ( LITERAL ) ; while ( ++ ID <= ID ) { ID ( * ID ) ; } if ( ID -> ID & ID ) while ( ID -- > 0 ) ID ( LITERAL ) ; break ; case ID : { static const char ID [ ] = LITERAL ; const char * ID ; ID ID ; ID = ( char * ) ID -> ID . ID ; if ( ID == ID ) { if ( ID == - 1 || ID >= ( long ) sizeof ( ID ) - 1 ) { ID = ID ; ID = sizeof ( ID ) - 1 ; ID -> ID &= ( ~ ID ) ; } else { ID = LITERAL ; ID = 0 ; } } else if ( ID != - 1 ) ID = ( ID ) ID ; else ID = ID ( ID ) ; ID -= ( ID > ID ) ? ID : ( long ) ID ; if ( ID -> ID & ID ) ID ( LITERAL ) ; if ( ! ( ID -> ID & ID ) ) while ( ID -- > 0 ) ID ( LITERAL ) ; while ( ( ID -- > 0 ) && * ID ) ID ( * ID ++ ) ; if ( ID -> ID & ID ) while ( ID -- > 0 ) ID ( LITERAL ) ; if ( ID -> ID & ID ) ID ( LITERAL ) ; } break ; case ID : { void * ID ; ID = ( void * ) ID -> ID . ID ; if ( ID != ID ) { ID = 1 6 ; ID = ( ID -> ID & ID ) ? ID : ID ; ID = 1 ; ID = ( ID ) ID ; ID = 0 ; goto ID ; } else { static const char ID [ ] = LITERAL ; const char * ID ; ID -= ( long ) ( sizeof ( ID ) - 1 ) ; if ( ID -> ID & ID ) while ( ID -- > 0 ) ID ( LITERAL ) ; for ( ID = ID ; * ID != LITERAL ; ++ ID ) ID ( * ID ) ; if ( ! ( ID -> ID & ID ) ) while ( ID -- > 0 ) ID ( LITERAL ) ; } } break ; case ID : { char ID [ 3 2 ] = LITERAL ; char * ID = & ID [ 1 ] ; ID ID = sizeof ( ID ) - ID ( ID ) ; int ID ; ID = - 1 ; if ( ID -> ID & ID ) ID = ID -> ID ; else if ( ID -> ID & ID ) ID = ( long ) ID [ ID -> ID ] . ID . ID . ID ; ID = - 1 ; if ( ID -> ID & ID ) ID = ID -> ID ; else if ( ID -> ID & ID ) ID = ( long ) ID [ ID -> ID ] . ID . ID . ID ; if ( ID -> ID & ID ) * ID ++ = LITERAL ; if ( ID -> ID & ID ) * ID ++ = LITERAL ; if ( ID -> ID & ID ) * ID ++ = LITERAL ; if ( ID -> ID & ID ) * ID ++ = LITERAL ; * ID = 0 ; if ( ID >= 0 ) { ID = ID ( ID , ID , LITERAL , ID ) ; ID += ID ; ID -= ID ; } if ( ID >= 0 ) { ID = ID ( ID , ID , LITERAL , ID ) ; ID += ID ; } if ( ID -> ID & ID ) * ID ++ = LITERAL ; if ( ID -> ID & ID ) * ID ++ = ( char ) ( ( ID -> ID & ID ) ? LITERAL : LITERAL ) ; else if ( ID -> ID & ID ) * ID ++ = ( char ) ( ( ID -> ID & ID ) ? LITERAL : LITERAL ) ; else * ID ++ = LITERAL ; * ID = 0 ; ( ID ) ( ID , ID , ID -> ID . ID ) ; for ( ID = ID ; * ID ; ID ++ ) ID ( * ID ) ; } break ; case ID : # ID ID if ( ID -> ID & ID ) * ( ID * ) ID -> ID . ID = ( ID ) ID ; else # ID if ( ID -> ID & ID ) * ( long * ) ID -> ID . ID = ( long ) ID ; else if ( ! ( ID -> ID & ID ) ) * ( int * ) ID -> ID . ID = ( int ) ID ; else * ( short * ) ID -> ID . ID = ( short ) ID ; break ; default : break ; } ID = * ID ++ ; } return ID ; }", "call_slices_vd": [[1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 175, 177, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 141, 142, 210, 211, 212, 213, 217]], "call_slices_sy": [[1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 175, 177, 191, 192, 193, 196, 197, 199, 200, 201, 202, 203, 206, 207, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 141, 142, 143, 145, 146, 147, 210, 211, 212, 213, 217]], "array_slices_vd": [[1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 210, 211, 212, 213, 217], [10, 12], [1, 7, 8, 13, 14], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 175, 176, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 180, 181, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 183, 184, 210, 211, 212, 213, 217], [1, 2, 4, 6, 7, 8, 10, 12, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 62, 63, 69, 70, 73, 74, 75, 78, 79, 82, 83, 84, 85, 86, 87, 88, 93, 94, 95, 96, 129, 130, 131, 134, 153, 154, 155, 156, 158, 210, 211, 212, 213, 217]], "array_slices_sy": [[1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 69, 70, 71, 73, 74, 75, 76, 78, 79, 80, 82, 83, 84, 85, 86, 87, 88, 90, 91, 92, 93, 94, 95, 96, 98, 99, 100, 101, 102, 104, 105, 106, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 119, 120, 121, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 137, 138, 141, 142, 143, 144, 145, 146, 147, 148, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 163, 164, 165, 166, 167, 168, 169, 170, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 195, 196, 197, 199, 200, 201, 202, 203, 204, 205, 206, 207, 209, 210, 211, 212, 213, 214, 215, 217], [10, 12, 93, 95, 98, 99, 100, 101, 102, 104, 105, 106, 108, 110, 119, 120, 121, 123], [1, 7, 8, 13, 14, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 27, 29, 30, 32, 33, 34, 35, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 69, 70, 71, 73, 74, 75, 76, 78, 79, 80, 82, 83, 84, 85, 86, 87, 88, 90, 91, 92, 93, 94, 95, 96, 98, 99, 100, 101, 102, 104, 105, 106, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 119, 120, 121, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 137, 138, 141, 142, 143, 144, 145, 146, 147, 148, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 163, 164, 165, 166, 167, 168, 169, 170, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 195, 196, 197, 199, 200, 201, 202, 203, 204, 205, 206, 207, 209, 210, 211, 212, 213, 214, 215, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 175, 176, 185, 186, 187, 188, 189, 191, 192, 193, 196, 197, 199, 200, 201, 202, 203, 206, 207, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 180, 181, 190, 191, 192, 193, 196, 197, 199, 200, 201, 202, 203, 206, 207, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 183, 184, 195, 196, 197, 199, 200, 201, 202, 203, 206, 207, 210, 211, 212, 213, 217], [1, 2, 4, 6, 7, 8, 10, 12, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 62, 63, 69, 70, 73, 74, 75, 78, 79, 82, 83, 84, 85, 86, 87, 88, 93, 94, 95, 96, 98, 99, 100, 101, 102, 104, 105, 106, 108, 110, 119, 120, 121, 123, 129, 130, 131, 134, 153, 154, 155, 156, 158, 210, 211, 212, 213, 217]], "arith_slices_vd": [[1, 2, 4, 6, 7, 8, 10, 12, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 61, 62, 63, 69, 70, 73, 74, 75, 78, 79, 82, 83, 84, 85, 86, 87, 88, 93, 94, 95, 96, 98, 129, 130, 131, 134, 153, 154, 155, 156, 158, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 2, 4, 6, 7, 8, 10, 12, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 62, 63, 69, 70, 73, 74, 75, 78, 79, 82, 83, 84, 85, 86, 87, 88, 92, 93, 94, 95, 96, 99, 129, 130, 131, 134, 153, 154, 155, 156, 158, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 133, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 153, 154, 165, 210, 211, 212, 213, 217], [10, 12], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 175, 177, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 73, 78, 83, 84, 85, 129, 130, 131, 134, 210, 211, 212, 213, 217]], "arith_slices_sy": [[1, 2, 4, 6, 7, 8, 10, 12, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 61, 62, 63, 69, 70, 73, 74, 75, 78, 79, 82, 83, 84, 85, 86, 87, 88, 93, 94, 95, 96, 98, 105, 108, 110, 119, 123, 129, 130, 131, 134, 153, 154, 155, 156, 158, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 69, 70, 71, 73, 74, 75, 76, 78, 79, 80, 82, 83, 84, 85, 86, 87, 88, 90, 91, 92, 93, 94, 95, 96, 98, 99, 100, 101, 102, 104, 105, 106, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 119, 120, 121, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 137, 138, 141, 142, 143, 144, 145, 146, 147, 148, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 163, 164, 165, 166, 167, 168, 169, 170, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 195, 196, 197, 199, 200, 201, 202, 203, 204, 205, 206, 207, 209, 210, 211, 212, 213, 214, 215, 217], [1, 2, 4, 6, 7, 8, 10, 12, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 62, 63, 69, 70, 73, 74, 75, 78, 79, 82, 83, 84, 85, 86, 87, 88, 92, 93, 94, 95, 96, 99, 100, 101, 102, 104, 105, 106, 108, 110, 119, 120, 121, 123, 129, 130, 131, 134, 153, 154, 155, 156, 158, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 133, 134, 143, 145, 146, 147, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 153, 154, 165, 166, 170, 210, 211, 212, 213, 217], [10, 12, 93, 95, 98, 99, 100, 101, 102, 104, 105, 106, 108, 110, 119, 120, 121, 123], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 175, 177, 191, 192, 193, 196, 197, 199, 200, 201, 202, 203, 206, 207, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 73, 78, 83, 84, 85, 86, 87, 88, 94, 95, 96, 98, 99, 100, 101, 102, 104, 105, 106, 108, 110, 119, 120, 121, 123, 129, 130, 131, 134, 210, 211, 212, 213, 217]], "ptr_slices_vd": [[1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 144, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 133, 134, 138, 141, 142, 143, 145, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 148, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 153, 210, 211, 212, 213, 217], [1, 2, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 153, 154, 156, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 153, 154, 165, 166, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 175, 176, 185, 186, 187, 188, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 52, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 180, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 183, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 60, 61, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 62, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 61, 63, 64, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 61, 63, 66, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 175, 176, 177, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 195, 196, 197, 199, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 73, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 2, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 73, 74, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 204, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 73, 78, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 73, 78, 83, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 73, 78, 83, 84, 85, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 73, 78, 83, 91, 109, 129, 130, 131, 134, 153, 154, 159, 210, 211, 212, 213, 217], [1, 2, 4, 6, 7, 8, 10, 12, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 60, 61, 62, 63, 69, 70, 73, 74, 75, 78, 79, 82, 83, 84, 85, 86, 87, 88, 92, 93, 94, 95, 96, 98, 99, 104, 105, 108, 110, 129, 130, 131, 134, 153, 154, 155, 156, 157, 158, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 73, 78, 83, 91, 111, 112, 129, 130, 131, 134, 153, 154, 159, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 60, 61, 63, 69, 70, 73, 75, 78, 79, 82, 114, 116, 129, 130, 131, 134, 153, 154, 155, 157, 210, 211, 212, 213, 217]], "ptr_slices_sy": [[1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 69, 70, 71, 73, 74, 75, 76, 78, 79, 80, 82, 83, 84, 85, 86, 87, 88, 90, 91, 92, 93, 94, 95, 96, 98, 99, 100, 101, 102, 104, 105, 106, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 119, 120, 121, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 137, 138, 141, 142, 143, 144, 145, 146, 147, 148, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 163, 164, 165, 166, 167, 168, 169, 170, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 195, 196, 197, 199, 200, 201, 202, 203, 204, 205, 206, 207, 209, 210, 211, 212, 213, 214, 215, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 144, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 133, 134, 138, 141, 142, 143, 145, 147, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 148, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 92, 93, 94, 95, 96, 98, 99, 100, 101, 102, 104, 105, 106, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 119, 120, 121, 123, 124, 129, 130, 131, 134, 153, 154, 155, 156, 157, 158, 159, 160, 163, 164, 165, 166, 167, 168, 169, 170, 173, 210, 211, 212, 213, 217], [1, 2, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 95, 98, 99, 100, 101, 102, 104, 105, 106, 108, 110, 119, 120, 121, 123, 129, 130, 131, 134, 153, 154, 156, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 153, 154, 165, 166, 170, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 175, 176, 185, 186, 187, 188, 189, 191, 192, 193, 196, 197, 199, 200, 201, 202, 203, 206, 207, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 52, 53, 54, 55, 56, 58, 59, 61, 64, 66, 98, 105, 108, 110, 119, 123, 129, 130, 131, 134, 143, 145, 147, 165, 166, 170, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 180, 181, 190, 191, 192, 193, 196, 197, 199, 200, 201, 202, 203, 206, 207, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 183, 184, 195, 196, 197, 199, 200, 201, 202, 203, 206, 207, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 60, 61, 100, 101, 102, 106, 108, 110, 114, 115, 116, 117, 119, 120, 121, 123, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 62, 65, 94, 95, 96, 98, 99, 100, 101, 102, 104, 105, 106, 108, 110, 119, 120, 121, 123, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 64, 65, 66, 67, 69, 70, 71, 73, 74, 75, 76, 78, 79, 80, 82, 83, 84, 85, 86, 87, 88, 90, 91, 92, 93, 94, 95, 96, 98, 99, 100, 101, 102, 104, 105, 106, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 119, 120, 121, 123, 124, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 61, 63, 64, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 61, 63, 66, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 70, 71, 73, 74, 75, 76, 78, 79, 80, 82, 83, 84, 85, 86, 87, 88, 90, 91, 94, 95, 96, 98, 99, 100, 101, 102, 104, 105, 106, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 119, 120, 121, 123, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 175, 176, 177, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 195, 196, 197, 199, 200, 201, 202, 203, 206, 207, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 73, 74, 75, 76, 78, 79, 80, 82, 83, 84, 85, 86, 87, 88, 90, 91, 94, 95, 96, 98, 99, 100, 101, 102, 104, 105, 106, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 119, 120, 121, 123, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 2, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 73, 74, 95, 98, 99, 100, 101, 102, 104, 105, 106, 108, 110, 119, 120, 121, 123, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 129, 130, 131, 134, 204, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 73, 78, 79, 80, 82, 83, 84, 85, 86, 87, 88, 90, 91, 94, 95, 96, 98, 99, 100, 101, 102, 104, 105, 106, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 119, 120, 121, 123, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 73, 78, 83, 84, 85, 86, 87, 88, 94, 95, 96, 98, 99, 100, 101, 102, 104, 105, 106, 108, 109, 110, 111, 112, 113, 119, 120, 121, 123, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 73, 78, 83, 84, 85, 86, 87, 88, 94, 95, 96, 98, 99, 100, 101, 102, 104, 105, 106, 108, 110, 119, 120, 121, 123, 129, 130, 131, 134, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 73, 78, 83, 91, 109, 129, 130, 131, 134, 153, 154, 159, 210, 211, 212, 213, 217], [1, 2, 4, 6, 7, 8, 10, 12, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 56, 58, 59, 60, 61, 62, 63, 69, 70, 73, 74, 75, 78, 79, 82, 83, 84, 85, 86, 87, 88, 92, 93, 94, 95, 96, 98, 99, 104, 105, 108, 110, 119, 123, 129, 130, 131, 134, 153, 154, 155, 156, 157, 158, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 61, 63, 69, 73, 78, 83, 91, 111, 112, 113, 129, 130, 131, 134, 153, 154, 159, 210, 211, 212, 213, 217], [1, 4, 6, 7, 8, 13, 14, 15, 16, 25, 33, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 53, 54, 55, 56, 58, 59, 60, 61, 63, 69, 70, 73, 75, 78, 79, 82, 114, 116, 117, 129, 130, 131, 134, 153, 154, 155, 157, 210, 211, 212, 213, 217]], "label": 0}, {"file_path": "../data/chrome_debian/raw_code_10to19/18_0.c", "code": "static bool dprintf_IsQualifierNoDollar ( const char * fmt ) {\n  # if defined ( MP_HAVE_INT_EXTENSIONS ) if ( ! strncmp ( fmt , \"I32\" , 3 ) || ! strncmp ( fmt , \"I64\" , 3 ) ) {\n  return TRUE ;\n  }\n  # endif switch ( * fmt ) {\n  case '-' : case '+' : case ' ' : case '#' : case '.' : case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : case 'h' : case 'l' : case 'L' : case 'z' : case 'q' : case '*' : case 'O' : # if defined ( MP_HAVE_INT_EXTENSIONS ) case 'I' : # endif return TRUE ;\n  default : return FALSE ;\n  }\n  }", "tokenized": "static ID ID ( const char * ID ) { # if ID ( ID ) if ( ! ID ( ID , LITERAL , 3 ) || ! ID ( ID , LITERAL , 3 ) ) { return ID ; } # ID switch ( * ID ) { case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : case LITERAL : # if ID ( ID ) case LITERAL : # ID return ID ; default : return ID ; }", "call_slices_vd": [], "call_slices_sy": [], "array_slices_vd": [], "array_slices_sy": [], "arith_slices_vd": [], "arith_slices_sy": [], "ptr_slices_vd": [], "ptr_slices_sy": [], "label": 0}, {"file_path": "../data/chrome_debian/raw_code_10to19/18_1.c", "code": "unsigned long # define BN_BYTES 8 # endif # ifdef SIXTY_FOUR_BIT # define BN_ULONG unsigned long long # define BN_BYTES 8 # endif # ifdef THIRTY_TWO_BIT # define BN_ULONG unsigned int # define BN_BYTES 4 # endif # define BN_BITS2 ( BN_BYTES * 8 ) # define BN_BITS ( BN_BITS2 * 2 ) # define BN_TBIT ( ( BN_ULONG ) 1 << ( BN_BITS2 - 1 ) ) # define BN_FLG_MALLOCED 0x01 # define BN_FLG_STATIC_DATA 0x02 # define BN_FLG_CONSTTIME 0x04 # define BN_FLG_SECURE 0x08 # if OPENSSL_API_COMPAT < 0x00908000L # define BN_FLG_EXP_CONSTTIME BN_FLG_CONSTTIME # define BN_FLG_FREE 0x8000 # endif void BN_set_flags ( BIGNUM * b , int n ) ;\n  int BN_get_flags ( const BIGNUM * b , int n ) ;\n  # define BN_RAND_TOP_ANY - 1 # define BN_RAND_TOP_ONE 0 # define BN_RAND_TOP_TWO 1 # define BN_RAND_BOTTOM_ANY 0 # define BN_RAND_BOTTOM_ODD 1 void BN_with_flags ( BIGNUM * dest , const BIGNUM * b , int flags ) ;\n  int BN_GENCB_call ( BN_GENCB * cb , int a , int b ) ;\n  BN_GENCB * BN_GENCB_new ( void ) ;\n  void BN_GENCB_free ( BN_GENCB * cb ) ;\n  void BN_GENCB_set_old ( BN_GENCB * gencb , void ( * callback ) ( int , int , void * ) , void * cb_arg ) ;\n  void BN_GENCB_set ( BN_GENCB * gencb , int ( * callback ) ( int , int , BN_GENCB * ) , void * cb_arg ) ;\n  void * BN_GENCB_get_arg ( BN_GENCB * cb ) ;\n  # define BN_prime_checks 0 # define BN_prime_checks_for_size ( b ) ( ( b ) >= 3747 ? 3 : ( b ) >= 1345 ? 4 : ( b ) >= 476 ? 5 : ( b ) >= 400 ? 6 : ( b ) >= 347 ? 7 : ( b ) >= 308 ? 8 : ( b ) >= 55 ? 27 : 34 ) # define BN_num_bytes ( a ) ( ( BN_num_bits ( a ) + 7 ) / 8 ) int BN_abs_is_word ( const BIGNUM * a , const BN_ULONG w ) ;\n  int BN_is_zero ( const BIGNUM * a ) ;\n  int BN_is_one ( const BIGNUM * a ) ;\n  int BN_is_word ( const BIGNUM * a , const BN_ULONG w ) ;\n  int BN_is_odd ( const BIGNUM * a ) ;\n  # define BN_one ( a ) ( BN_set_word ( ( a ) , 1 ) ) void BN_zero_ex ( BIGNUM * a ) ;\n  # if OPENSSL_API_COMPAT >= 0x00908000L # define BN_zero ( a ) BN_zero_ex ( a ) # else # define BN_zero ( a ) ( BN_set_word ( ( a ) , 0 ) ) # endif const BIGNUM * BN_value_one ( void ) ;\n  char * BN_options ( void ) ;\n  BN_CTX * BN_CTX_new ( void ) ;\n  BN_CTX * BN_CTX_secure_new ( void ) ;\n  void BN_CTX_free ( BN_CTX * c ) ;\n  void BN_CTX_start ( BN_CTX * ctx ) ;\n  BIGNUM * BN_CTX_get ( BN_CTX * ctx ) ;\n  void BN_CTX_end ( BN_CTX * ctx ) ;\n  int BN_rand ( BIGNUM * rnd , int bits , int top , int bottom ) ;\n  int BN_priv_rand ( BIGNUM * rnd , int bits , int top , int bottom ) ;\n  int BN_rand_range ( BIGNUM * rnd , const BIGNUM * range ) ;\n  int BN_priv_rand_range ( BIGNUM * rnd , const BIGNUM * range ) ;\n  int BN_pseudo_rand ( BIGNUM * rnd , int bits , int top , int bottom ) ;\n  int BN_pseudo_rand_range ( BIGNUM * rnd , const BIGNUM * range ) ;\n  int BN_num_bits ( const BIGNUM * a ) ;\n  int BN_num_bits_word ( BN_ULONG l ) ;\n  int BN_security_bits ( int L , int N ) ;\n  BIGNUM * BN_new ( void ) ;\n  BIGNUM * BN_secure_new ( void ) ;\n  void BN_clear_free ( BIGNUM * a ) ;\n  BIGNUM * BN_copy ( BIGNUM * a , const BIGNUM * b ) ;\n  void BN_swap ( BIGNUM * a , BIGNUM * b ) ;\n  BIGNUM * BN_bin2bn ( const unsigned char * s , int len , BIGNUM * ret ) ;\n  int BN_bn2bin ( const BIGNUM * a , unsigned char * to ) ;\n  int BN_bn2binpad ( const BIGNUM * a , unsigned char * to , int tolen ) ;\n  BIGNUM * BN_lebin2bn ( const unsigned char * s , int len , BIGNUM * ret ) ;\n  int BN_bn2lebinpad ( const BIGNUM * a , unsigned char * to , int tolen ) ;\n  BIGNUM * BN_mpi2bn ( const unsigned char * s , int len , BIGNUM * ret ) ;\n  int BN_bn2mpi ( const BIGNUM * a , unsigned char * to ) ;\n  int BN_sub ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n  int BN_usub ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n  int BN_uadd ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n  int BN_add ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b ) ;\n  int BN_mul ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , BN_CTX * ctx ) ;\n  int BN_sqr ( BIGNUM * r , const BIGNUM * a , BN_CTX * ctx ) ;\n  void BN_set_negative ( BIGNUM * b , int n ) ;\n  int BN_is_negative ( const BIGNUM * b ) ;\n  int BN_div ( BIGNUM * dv , BIGNUM * rem , const BIGNUM * m , const BIGNUM * d , BN_CTX * ctx ) ;\n  # define BN_mod ( rem , m , d , ctx ) BN_div ( NULL , ( rem ) , ( m ) , ( d ) , ( ctx ) ) int BN_nnmod ( BIGNUM * r , const BIGNUM * m , const BIGNUM * d , BN_CTX * ctx ) ;\n  int BN_mod_add ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m , BN_CTX * ctx ) ;\n  int BN_mod_add_quick ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m ) ;\n  int BN_mod_sub ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m , BN_CTX * ctx ) ;\n  int BN_mod_sub_quick ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m ) ;\n  int BN_mod_mul ( BIGNUM * r , const BIGNUM * a , const BIGNUM * b , const BIGNUM * m , BN_CTX * ctx ) ;\n  int BN_mod_sqr ( BIGNUM * r , const BIGNUM * a , const BIGNUM * m , BN_CTX * ctx ) ;\n  int BN_mod_lshift1 ( BIGNUM * r , const BIGNUM * a , const BIGNUM * m , BN_CTX * ctx ) ;\n  int BN_mod_lshift1_quick ( BIGNUM * r , const BIGNUM * a , const BIGNUM * m ) ;\n  int BN_mod_lshift ( BIGNUM * r , const BIGNUM * a , int n , const BIGNUM * m , BN_CTX * ctx ) ;\n  int BN_mod_lshift_quick ( BIGNUM * r , const BIGNUM * a , int n , const BIGNUM * m ) ;\n  BN_ULONG BN_mod_word ( const BIGNUM * a , BN_ULONG w ) ;\n  BN_ULONG BN_div_word ( BIGNUM * a , BN_ULONG w ) ;\n  int BN_mul_word ( BIGNUM * a , BN_ULONG w ) ;\n  int BN_add_word ( BIGNUM * a , BN_ULONG w ) ;\n  int BN_sub_word ( BIGNUM * a , BN_ULONG w ) ;\n  int BN_set_word ( BIGNUM * a , BN_ULONG w ) ;\n  BN_ULONG BN_get_word ( const BIGNUM * a )", "tokenized": "int ID ( const ID * ID , int ID )", "call_slices_vd": [], "call_slices_sy": [], "array_slices_vd": [], "array_slices_sy": [], "arith_slices_vd": [], "arith_slices_sy": [], "ptr_slices_vd": [], "ptr_slices_sy": [], "label": 1}, {"file_path": "../data/chrome_debian/raw_code_10to19/19_0.c", "code": "static int alloc_addbyter ( int output , FILE * data ) {\n  struct asprintf * infop = ( struct asprintf * ) data ;\n  unsigned char outc = ( unsigned char ) output ;\n  if ( ! infop -> buffer ) {\n  infop -> buffer = malloc ( 32 ) ;\n  if ( ! infop -> buffer ) {\n  infop -> fail = 1 ;\n  return - 1 ;\n  }\n  infop -> alloc = 32 ;\n  infop -> len = 0 ;\n  }\n  else if ( infop -> len + 1 >= infop -> alloc ) {\n  char * newptr = NULL ;\n  size_t newsize = infop -> alloc * 2 ;\n  if ( newsize > infop -> alloc ) newptr = realloc ( infop -> buffer , newsize ) ;\n  if ( ! newptr ) {\n  infop -> fail = 1 ;\n  return - 1 ;\n  }\n  infop -> buffer = newptr ;\n  infop -> alloc = newsize ;\n  }\n  infop -> buffer [ infop -> len ] = outc ;\n  infop -> len ++ ;\n  return outc ;\n  }", "tokenized": "static int ID ( int ID , ID * ID ) { struct ID * ID = ( struct ID * ) ID ; unsigned char ID = ( unsigned char ) ID ; if ( ! ID -> ID ) { ID -> ID = ID ( 3 2 ) ; if ( ! ID -> ID ) { ID -> ID = 1 ; return - 1 ; } ID -> ID = 3 2 ; ID -> ID = 0 ; } else if ( ID -> ID + 1 >= ID -> ID ) { char * ID = ID ; ID ID = ID -> ID * 2 ; if ( ID > ID -> ID ) ID = ID ( ID -> ID , ID ) ; if ( ! ID ) { ID -> ID = 1 ; return - 1 ; } ID -> ID = ID ; ID -> ID = ID ; } ID -> ID [ ID -> ID ] = ID ; ID -> ID ++ ; return ID ; }", "call_slices_vd": [[1, 2, 4, 13, 15, 16], [1, 2, 4, 5]], "call_slices_sy": [[1, 2, 4, 13, 15, 16, 17, 18, 19, 21, 22, 24, 25, 26], [1, 2, 4, 5, 6, 7, 8, 10, 11, 24, 25, 26]], "array_slices_vd": [[1, 2, 3, 4, 5, 6, 11, 13, 14, 15, 16, 17, 21, 22, 24]], "array_slices_sy": [[1, 2, 3, 4, 5, 6, 11, 13, 14, 15, 16, 17, 21, 22, 24]], "arith_slices_vd": [[1, 2, 4, 13], [1, 2, 4, 13, 15]], "arith_slices_sy": [[1, 2, 4, 13, 14, 15, 16, 17, 18, 19, 21, 22, 24, 25, 26], [1, 2, 4, 13, 15, 16, 17, 18, 19, 21, 22, 24, 25, 26]], "ptr_slices_vd": [[1, 2, 4], [1, 2, 4, 5], [1, 2, 4, 5, 6, 7], [1, 2, 4, 5, 6, 10], [1, 2, 4, 5, 6, 11], [1, 2, 4, 13], [1, 2, 4, 13, 15], [1, 2, 4, 13, 14, 15, 16, 17, 18], [1, 2, 4, 13, 14, 15, 16, 17, 21], [1, 2, 4, 13, 14, 15, 16, 17, 22], [1, 2, 3, 4, 5, 6, 11, 13, 14, 15, 16, 17, 21, 22, 24], [1, 2, 4, 5, 6, 11, 13, 14, 15, 16, 17, 22, 25]], "ptr_slices_sy": [[1, 2, 4, 5, 6, 7, 8, 10, 11, 13, 14, 15, 16, 17, 18, 19, 21, 22, 24, 25, 26], [1, 2, 4, 5, 6, 7, 8, 10, 11, 24, 25, 26], [1, 2, 4, 5, 6, 7], [1, 2, 4, 5, 6, 10], [1, 2, 4, 5, 6, 11, 24, 25], [1, 2, 4, 13, 14, 15, 16, 17, 18, 19, 21, 22, 24, 25, 26], [1, 2, 4, 13, 15, 16, 17, 18, 19, 21, 22, 24, 25, 26], [1, 2, 4, 13, 14, 15, 16, 17, 18], [1, 2, 4, 13, 14, 15, 16, 17, 21, 24], [1, 2, 4, 13, 14, 15, 16, 17, 22, 24, 25], [1, 2, 3, 4, 5, 6, 11, 13, 14, 15, 16, 17, 21, 22, 24], [1, 2, 4, 5, 6, 11, 13, 14, 15, 16, 17, 22, 25]], "label": 0}]